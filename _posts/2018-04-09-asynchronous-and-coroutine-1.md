---
layout:     post
title:      "详解异步回调和协程实现原理(上)"
subtitle:   "异步和协程的基本概念"
date:       2018-04-9 12:00:00
author:     "Ma HaoJie"
header-img: "img/hacker.jpg"
tags:
    - concurrent
    - asynchronous
    - coroutine
---

从最近的语言发展可以看出，支持异步和高并发是语言发展的趋势，如新兴的 Go、Rust、Elixir 等编程语言都将其支持异步和高并发作为主要“卖点”，技术变化趋势如此。今天我就在这里详细讨论下异步回调和协程的基本概念以及实现原理，本文将分成不同的章节，深入操作系统甚至是硬件层面来详细讨论这个话题。



# 1. 基础知识

## 1.1 阻塞/非阻塞与同步/异步

对linux IO有一些了解的同学一般都会熟悉这几个概念，但是这些概念之间常常容易搞混，我这里从基本的概念开始介绍，再延伸到IO以及框架方面。

先介绍下同步和异步:
* 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)， 单机上就是线程和内核的通信方式，分布式系统情况下是主机间通信方式.
* 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

然后是阻塞和非阻塞:
* 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
* 学过操作系统的话应该都知道进程/线程在内核中是有相应的状态的, 而阻塞/非阻塞关注的就是调用后线程的状态, 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

这么说可能有点复杂，下面通过一个例子来说明。
老马爱喝咖啡, 经常需要煮热水泡咖啡。出场人物：老张，两把（普通水壶，简称水壶；会响的水壶，简称响水壶）水壶。
1. 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己这样有点傻。
2. 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
3. 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。

所谓同步异步，只是对于水壶(内核)而言。普通水壶，同步；响水壶，异步。
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。
同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。

所谓阻塞非阻塞，仅仅对于老张(线程)而言。
可以看出异步是有相当大的优势的。

有的人可能想那异步阻塞呢？你都有一个会响的水壶了，还等在那干什么？？？

## 1.2 Linux网络IO

了解了这些，我们再来聊聊操作系统提供的网络I/O吧，一般来说linux内核提供的I/O系统调用大致有如下几种：
* 同步模型（synchronous I/O）
* 阻塞I/O（bloking I/O）
* 非阻塞I/O（non-blocking I/O）
* 多路复用I/O（multiplexing I/O）
* 信号驱动式I/O（signal-driven I/O）
* 异步I/O（asynchronous I/O）

一个IO操作通常包括两个不同阶段：

1. 等待数据准备好；
2. 从内核向进程/从进程向内核复制数据。

阻塞I/O就是说进程在发起一个I/O系统调用后立刻进入挂起状态，待内核完成第一步后再将进程设置为就绪态，参与调度。

非阻塞I/O是通过进程把一个套接字设置成非阻塞来实现的， 这是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。

多路复用I/O是linux内核在2.6版本提供的相关系统调用，这个系统调用通过监控多个套接字， 并将其设置为非阻塞状态，然后通过轮询的方式来监控所有套接字.

linux提供了select, poll, epoll三种相关的系统调用, select最多只支持1024个套接字，poll和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制, epoll是对poll的增强，被公认为Linux2.6下性能最好的多路I/O就绪通知方法， epoll本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知, 同时epoll使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销

信号驱动I/O用的很少，这里不讨论了.

其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要由内核处理。

异步I/O也是内核提供的系统调用，异步I/O在调用后立刻返回， 在调用的时候需要提供相应的回调函数（callback), 当数据读取完成后，内核会调用相应的回调函数。

Linux AIO早就被提上议程，目前比较知名的有Glibc的AIO与Kernel Native AIO, Glibc的AIO本质是通过线程实现的,它牵涉了3个线程， 主线程新建一个线程来调用阻塞的I/O函数，当函数返回时，又创建了一个线程来执行我们预设的异步回调函数, Kernel Native AIO几乎提供了近乎完美的异步方式，但如果你对它抱有太高期望的话，你会再一次感到失望.目前的Kernel AIO仅支持 O_DIRECT 方式来对磁盘读写，这意味着，你无法利用系统的缓存，同时它要求读写的的大小和偏移要以区块的方式对齐，参考Nginx的作者Igor Sysoev的[评论](http://forum.nginx.org/read.php?2,113524,113587#msg-113587).

但是呢windows平台下的异步I/O接口IOCP就相当完善了，感性兴趣的可以自己找资料了解一下。




## 1.3 更广泛意义上的同步/异步，阻塞/非阻塞
看到这你是不是觉得对同步/异步, 阻塞/非阻塞了如指掌了？错，上面的说法是错误的，或者说是不够全面的，为什么呢？

这是因为同步、异步、阻塞、非阻塞这几个概念其实在不同的层次就有不同的意义和实现，最简单是分3个层次的：CPU层次；线程层次；程序员感知层次。

1. CPU层次在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。
2. 线程层次在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路：多线程（同步阻塞）；IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。
3. 程序员感知层次在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的方式还是异步的方式来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。总结因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

再详细一点来说, 一个网络包从应用程序A发到另一台电脑上的应用程序B，需要经历：
1. 从A的业务代码到A的软件框架
2. 从A的软件框架到计算机的操作系统内核
3. 从A所在计算机的内核到网卡
4. 从网卡经过网线发到交换机等设备，层层转发，到达B所在计算机的网卡
5. 从B所在计算机的网卡到B所在计算机的内核
6. 从B所在计算机的内核到B的程序的用户空间
7. 从B的软件框架到B的业务代码

这个层级关系就像是过程调用一样，前一级调用后一级的功能，后一级返回一个结果给前一级（比如：成功，或者失败）。只有在单独一级的调用上，可以说同步还是异步的问题。所谓同步，是指调用协议中结果在调用完成时返回，这样调用的过程中参与双方都处于一个状态同步的过程。而异步，是指调用方发出请求就立即返回，请求甚至可能还没到达接收方，比如说放到了某个缓冲区中，等待对方取走或者第三方转交；而结果，则通过接收方主动推送，或调用方轮询来得到。从这个定义中，我们看，首先1和7，这取决于软件框架的设计，如果软件框架可以beginXXX，然后立即返回，这就是一种异步调用，再比如javascript当中的异步HTTP调用，传入参数时提供一个回调函数，回调函数在完成时调用，再比如协程模型，调用接口后马上切换到其他协程继续执行，在完成时由框架切换回到协程中，这都是典型的异步接口设计。而2和6，其实都需要调用方自己把数据在内核和用户空间里搬来搬去，其实都是同步接口，除非是IOCP这样的专门的异步传输接口，所以这一级其实是同步的，阻塞与非阻塞的区别其实是影响调用接口的结果（在特定条件下是否提前返回结果），而不是调用方式。3和5，内核一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。4，以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的。

总结来说，讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在3中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。


## 1.4 并发编程模型
常见的并发模型包括下面几种：
1. 线程与锁并发模型
2. actor模型, scala采用的模型
3. 函数式编程, ruby, c#等
4. 通讯顺序进程（Communicating Sequential Processe），go语言采用的模型
5. 数据并行
6. Lambda架构

这些都是目前主流的并发模型，不同的框架和语言都选择了不同的并发模型，比如现在很火的go语言就使用了GSP模型， 这里由于篇幅问题就不详细讨论了，感兴趣的可以看看《七周七并发模型》这本书，或者等我后续更新博客，会讨论相关内容。

## 1.5 用户态线程（green thread)，协程
协程诞生解决的是低速IO和高速的CPU的协调问题，解决这类问题主要有两个有效途径：
1. 使用异步回调的编程模型（libevent、libev、redis、Nginx、memcached这类）
2. 协程（golang、gevent）

对比之下协程的编程难度较低，而且也没有"callback hell"的问题， 不要求编程人员要有那么高的抽象思维能力。再加上golang在这方面优秀的实践（go语言通过协程和channel实现了CSP模型)，协程目前的前途还是一片光明的。

那么协程是如何实现的呢?

一般来说线程有三种:
1. 内核态线程, 是指由内核提供的线程相关的系统调用，一般来说编程语言都会对其进行封装实现成一个方便使用的库， 比如java的Thread，本质上都是使用内核提供的内核态线程。
2. 用户态线程, 用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁完全由库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。也就是所谓的协程。

内核态线程和其他两种线程相比, 线程切换的时候需要陷入内核，但是呢很多时候我们需要进行切换的时候并不需要内核提供的功能，使用内核态线程相当于引入了额外的延时，因此其速度和效率不如内核态线程，此外内核态线程的内存开销也比较小。

这样将是不是有点晦涩，下面我们梳理一下linux进程，线程的发展过程就可以更加清楚的理解这个概念。

在早期的linux系统里，是没有线程支持的，操作系统分配资源的单位是进程，然后执行单元也是进程。说详细点就是，每个进程有自己的内存，文件描述符，IO端口等，你不能随便访问其他进程的资源，分配给你，就是你的了，别人看不到。而那时候的进程都是单线程的，基本是为每个请求分配一个线程。优点是更轻量，建立和释放速度更快，而且多个上下文间的通讯速度非常快。缺点是一个线程出现问题容易将整个系统搞崩溃。不知道哪天人注意到开个千儿八百个进程机器就卡死了，这怎么行，所以就想出一个办法，只搞一个进程，里面有一坨打开的网络连接和文件，用select这个系统调用对io事件同时进行监听，谁先来我就处理谁。然而发现性能也不好，没什么卵用。

这时就引入了线程的实现（线程的概念是很早的概念了，但在操作系统中真正地大规模使用比起概念的提出可能要晚了二十年左右）。在linux里，早期线程的实现，其实就是引入了个PCB（process control block），然后有个独立的栈。有人叫它轻量级进程，有人叫它线程，总之是提高了整个系统的并发能力就是了。当然，后来线程机制做得越来越完善，并发控制，消息等都有了很好的支持，就是大家现在看到的样子了。线程有自己的独立的栈，调度也依赖操作系统，但是大家还是不满意，觉得线程消耗资源太大了，例如在linux上，一个线程默认的栈大小是1M，创建几万个线程就压力山大。所以，后来在编程语言的层面上，就有了用户态线程，即协程。目前来说，编程语言里对协程支持最好的是go语言。协程使用栈内存是按需使用的，所以可以随随便便创建百万级的协程。而这些协程本质上还是要依托于具体的操作系统线程去执行的。比如说我创建了M个协程，然后在N个线程上执行，这就是M：N的方案。显然，Java里是没有协程的。当然，现在OpenJDK社区的 loom 项目正在努力为JDK增加协程。

其实协程就只是简单的用户态线程，我们常用的语言提供的线程接口，比如java的Thread，本质上都是使用内核提供的内核态线程,

但是协程也并不是完美的，其内存开销仍然比异步回调要大（一个协程一个栈，而异步回调的话一个event loop一共就一个栈）, 但是现在内存也是便宜了，不算是瓶颈。人最关注的是“千万不能堵着（block）”，要千方百计让CPU转起来，这样concurrency才能上去。而到处乱开协程（因为比线程便宜啊）就能达到这个效果，开十万个协程内存也没爆炸，跑上24个就能把CPU打满。所以异步回调的这个优势已经没了。


# 2 常见异步编程以及协程工具

各大编程语言为了支持异步编程或者协程，一般会通过包的方式来封装相关的native实现提供更加灵活方便使用的接口，这里我就讲一讲java, python， c++以及go语言提供的工具。

## 2.1 java工具包

java常用的异步编程工具包括NIO, Netty, vert.x等.

java最初提供的异步I/O接口是NIO, NIO通过底层封装操作系统提供的多路复用机制（如select, poll, epoll)提供相应的异步编程接口, 但是NIO一直以来广受诟病，这是因为NIO没能屏蔽底层的细节，实现起来也有很多的坑.

因为NIO很不好用，有一个叫做trustin lee的韩国人说，既然这么不好用, 不如大家一起来重新创造一个，于是java社区的程序员们合力开发了一个称为Netty的库, 这个库在NIO的基础上进行了改进，主要是屏蔽了底层细节，以及对TCP/UDP编程进行了简化和封装，提供了更容易使用的网络编程接口，让你可以根据自己的需要封装独特的HTTP Server或者FTP Server.

Vert.x是一个事件驱动框架，可以帮助我们构建现代、灵活、可扩展的程序, 它基本上囊括了开发网络应用时需要用到的所有组件，不管是搭建服务、路由管理、用户权限理、数据库对接、网络通讯、集群管理……都可以用 Vert.x 搞定.它和netty有着紧密的联系, 因为netty只负责处理网络io部分，有一个人叫做tim fox的人到了red hat之后遇到了trustin lee，于是在trustin的指导下, 他跟norman等人将他在vmware时候制作的node.x（基于node.js原理）结合actor model等制作出了vert.x.现在netty主要是在apple工作的norman主要维护, trustin已经不怎么贡献了，忙于他们韩国社交公司line的事业中去了, tim也已经从vert.x的位置上退下来，上个月刚进facebook伦敦.

## 2.2 c++工具包
c++这块常用的包括libevent以及Nginx

由于POSIX标准的滞后性，事件通知API的混乱一直保持到现在， 所有就有libevent、libev甚至后面的libuv的出现为跨平台编程扫清障碍， libevent是一个异步事件处理软件函式库，以BSD许可证发布。 libevent提供了一组应用程序编程接口（API），让程序员可以设定某些事件发生时所执行的函式，也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。


按照libevent的官方网站，libevent库提供了以下功能：当一个文件描述符的特定事件 （如可读，可写或出错）发生了，或一个定时事件发生了， libevent就会自动执行用户指定的回调函数，来处理事件。

目前，libevent已支持以下接口/dev/poll, kqueue(2), event ports, select(2), poll(2) 和epoll(4)。libevent的内部事件机制完全是基于所使用的接口的。因此libevent非常容易移植， 也使它的扩展性非常容易。目前，libevent已在以下操作系统中编译通过： Linux，BSD，Mac OS X，Solaris和Windows。

libevent的高明之处还在于，它把fd读写、信号、DNS、定时器甚至idle（空闲） 都抽象化成了event（事件）。

Nginx是利用异步事件驱动的架构实现的一个http服务器。对Nginx目前不是特别了解，后面再详细讨论。

## 2.3 python工具包
python主要是通过协程实现异步编程, 但是python, java这种语言却没有提供协程的实现，或者说有相关实现但是并不流行这是为什么呢？

这是因为协程所完成的异步能力本质还是依赖底层的非阻塞I/O操作， 但是C++/java的io库，例如http/数据/缓存等都是基于阻塞io实现的，协程调用外部的库的时候依旧会阻塞，这就导致了当前线程中所有的协程都阻塞，完全丧失了异步能力。而lua, golang等语言相关的底层IO库就提供了协程支持，才可以使用。而Python这样的动态语言，可以使用monkey patch的方式替换系统的IO实现。gevent就是这种做法，这也是使用gevent的greenlet的时候，一般必须要在使用前做monkey patch的原因.
主要通过gevent,

gevent让用户能够按照同步的方式来编写异步程序，但是gevent内部还是封装的libev异步事件循环, Python这样的动态语言，可以使用monkey patch的方式替换系统的IO实现。gevent就是这种做法，这也是使用gevent的greenlet的时候，一般必须要在使用前做monkey patch的原因

python所提供的相关异步支持包括gevent, asyncio, aiohttp, async/await语法, asyncio.coroutine注解和yield from关键字实现

gevent就如上文所说是通过monkey patch的方式替换了IO实现， 但是这样的实现实际上非常的不优雅，不pythonic, 所以python社区又提供了asyncio, aiohttp，以及后来的async/await，这是个很大的话题，由于篇幅，这里就不讨论了，在下一部分讨论

# 3. Reference
[怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)

[python3.5 协程原理](https://juejin.im/entry/56ea295ed342d300546e1e22)

[linux AIO](http://www.yeolar.com/note/2012/12/16/linux-aio/)

[linux kernel AIO这个奇葩](http://www.wzxue.com/linux-kernel-aio%E8%BF%99%E4%B8%AA%E5%A5%87%E8%91%A9/)

[七周七语言总结](http://zhouchaowei.com/2015/12/19/%E3%80%8A%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%AF%BC%E5%9B%BE/)

[进程，轻量级进程和用户态线程](https://blog.csdn.net/jack05/article/details/5281079)

[Scala与Golang的并发实现对比](https://zhuanlan.zhihu.com/p/20009659)

[java NIO, Netty和Vert.x的区别联系](https://www.zhihu.com/question/20853629)

[awesome java](www.github.com/awesome_java)

[awesome python](www.github.com/awesome_python)

[awesome c++](www.githubh.com/awesome_cpp)

# 4. 总结
上篇讨论了异步/同步，阻塞/非阻塞的概念意义，以及回调和协程两种对异步编程的实现方式，最后讨论了相关语言提供的编程工具， 在接下来的中篇中我将讨论这些流行库的内部原理和使用经验。

未完待续.....
